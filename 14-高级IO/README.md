### 第十四章  高级I/O

##### 非阻塞IO

系统调用分为低速系统调用和其他，低速调用可能会使进程永远阻塞，包括：

* 如果文件不存在，读操作
* 如果数据不能被立即接受，写操作
* 某些条件发生前打开某些类型的文件（管道中无空间，网络流控制）
* 对已经加强制记录锁的文件进行读写
* 某些ioctl操作
* 某些进程间通信函数

对于一个文件描述符，有两种方法指定为非阻塞

1. 如果调用open，可指定O_NONBLOCK
2. 如果已经打开，可调用fcntl，由该函数打开O_NONBLOCK

##### 记录锁

当第一个进程正在读或写文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区，记录即文件的一个区域或整体

```
#include<fcntl.h>  
int fcntl(int fd, int cmd ,struct flock* lock);
// 若成功，依赖cmd，若出错，返回-1

struct flock
{
    short l_type;    /*锁的类型：F_RDLCK,F_WRLCK,F_UNLCK*/
    short l_whence;  /*偏移量的起始位置：SEEK_SET,SEEK_CUR,SEEK_END*/
    off_t l_start;   /*加锁的起始偏移，0且l_whence为SEEK_SET且l_len为0表示对整个文件加锁*/
    off_t l_len;     /*上锁字节：0表示锁的范围扩展到最大可能偏移量*/
    pid_t l_pid;     /*锁的属主进程ID */
}; 
```

加读锁时，必须读打开，加写锁时，必须写打开，cmd的三种类型：

* F_GETLK：判断由lock描述的锁是否会被另外一把锁排斥（阻塞）
* F_SETLK：设置由lock描述的锁
* F_SETLKW：F_SETLK的阻塞版本，W表示wait

设置或释放文件上的一把锁时，系统会组合或分裂相邻区，如100-199字节加锁区，需解锁150字节，内核将维持两把锁，一100-149字节，二151-199字节，如果再对150字节加锁，系统会把三个相邻的加锁区合并成一个

记录锁的自动继承和释放的规则：

1. 当一个进程终止时，它建立的所有锁全部释放；无论一个描述符何时关闭，该进程通过这一描述符引用的文件上的任何一把锁全部释放
2. 由fork产生的子进程不继承父进程设置的锁
3. 在执行exec后，新程序可以继承原执行程序的锁，除非该文件未设置执行关闭标志

