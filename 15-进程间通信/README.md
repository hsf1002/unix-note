### 第十五章  进程间通信

##### 引言

```
IPC类型

半双工管道
FIFO
全双工管道
命名全双工管道
XSI信号量
XSI消息队列
XSI共享存储
消息队列(实时)
信号量
共享存储(实时)
套接字
STREAMS
```

##### 管道

局限：

* 历史上，实现为半双工，虽然有些系统提供全双工管道
* 只能在具有公共祖先的两个进程之间使用，通常是在fork之后的父进程和子进程之间使用

FIFO没有第二种局限，域套接字没有这这两种局限，尽管如此，半双工管道仍然是最常用的IPC形式

```
#include <unistd.h>

int pipe(int fd[2]);	
// 若成功，返回0，若出错，返回-1
```

fd[0]为读打开，fd[1]为写打开，fd[1]的输出是fd[0]的输入

单个进程的管道几乎没有任何作用，通常，进程先调用pipe，再fork，从而创建从父进程到子进程的IPC通道；从父进程->子进程的管道，父进程关闭读端，子进程关闭写端，从子进程->父进程的管道，则相反；当管道的一端被关闭后，以下两条规则起作用：

1. 当读一个写端已被关闭的管道时，所有数据被读取后，read返回0，表示文件结束
2. 当写一个读端已被关闭的管道时，则产生信号SIGPIPE，若忽略此信号或从信号处理函数返回，write返回-1，errno设置为EPIPE

常量PIPE_BUF规定了内核的管道缓冲区大小，可以用pathconf或fpathconf确定

##### 函数popen和pclose

常见的操作时创建一个文件连接到另一个进程的管道，然后读其输出或向其输入端发送数据，popen和pclose实现的操作是：创建一个管道，fork一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止

```
#include <stdio.h>

FILE *popen (const char *cmdstring , const char * type);
// 若成功，返回文件指针，若出错，返回NULL
int pclose (FILE *fp);
// 若成功，返回cmdstring的终止状态，若出错，返回-1
```

* popen先执行fork，然后调用exec执行cmdstring，并且返回一个标准IO文件指针，如果type是r，则文件指针连接到cmdstring的标准输出，如果type是r，则文件指针连接到cmdstring的标准输入

* pclose关闭标准IO流，等待命令终止，然后返回shell的终止状态

##### 协同进程

当一个过滤程序既产生某个过滤程序的输入，又读取过滤程序的输出时，就变成了协同进程，Korn shell提供了协同进程，而其他shell没有提供；通常在shell的后台运行，其标准输入和标准输出通过管道连接到另一个程序；popen只提供连接到另一个进程的标准输入或标准输出的单向管道，而协同进程则连接到另一个进程的两个单向管道：一个连接到其标准输入，另一个则来自其标准输出，我们将数据写到其标准输入，处理后，再从其标准输出读取数据

